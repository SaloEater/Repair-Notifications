if not zzzz_arti_jamming_repairs then
	printf("zzzz_arti_jamming_repairs not found | unloading module")
end
printf("loading module: zzzz_arti_jamming_repairs_repair_notifications")

local old_zzzz_arti_jamming_repairs_replace_part = zzzz_arti_jamming_repairs.replace_part
zzzz_arti_jamming_repairs.replace_part = function(id, part, kit_name, clean)
	zzzz_arti_jamming_repairs.print_dbg("replacing part %s on item %s", part, id)
	local kit = db.actor:object(kit_name)
	local parts = se_load_var(id, nil, "parts")
	if parts and parts[part] then
		parts[part] = 99
		local left = utils_item.discharge(kit)

		if clean then
			local str = game.translate_string("st_news_cleaned") .. " " .. ui_item.get_sec_name(part) .. "\\n" .. repair_notifications.item_charges_string(kit, left)
			news_manager.send_tip(db.actor, str, nil, "swiss_knife", 6000)
		else
			local str = game.translate_string("st_news_parts_success") .. " " .. ui_item.get_sec_name(part) .. "\\n" .. repair_notifications.item_charges_string(kit, left)
			news_manager.send_tip(db.actor, str, nil, "swiss_knife", 6000)
		end

		-- restore condition too
		local wpn = level.object_by_id(id)
		wpn:set_condition( clamp(wpn:condition() + 0.1, 0, 0.999) )
		if id == zzzz_arti_jamming_repairs.current_id() then
			zzzz_arti_jamming_repairs.reset_cgd()
		end
	end

	GetActorMenu():UpdateItems()
	GetActorMenu():UpdateSlots()
end

function timer_disassembly_weapon(npc_id, result_details, result_conditions, name, obj_d_section, new_con)
	-- Who is item owner? we must give them the parts
	local npc = npc_id and get_object_by_id(npc_id)
	if (not npc) then
		printf("~ item_parts timer | no owner found")
		return
	end

	-- Send messages to the actor
	if #result_details > 0 then
		local parts_text = item_parts.create_disassemble_list(result_details)
		actor_menu.set_item_news('success', 'weapon_ammo', "st_dis_text_7", name, repair_notifications.get_disassemble_string(obj_d_section, new_con), parts_text)
	else
		actor_menu.set_item_news('fail', 'weapon', "st_dis_text_2", name, repair_notifications.item_condition_string(obj_d_section, new_con))
	end

	-- Creating parts in inventory
	for i=1,#result_details do
		if result_conditions[i] and result_conditions[i] > 0 then
			local se_result = alife_create(result_details[i], npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id(), false)
			local data_result = utils_stpk.get_item_data(se_result)
			data_result.condition = clamp( (result_conditions[i]/100) , zzzz_arti_jamming_repairs.min_con_obj , zzzz_arti_jamming_repairs.max_con_obj )
			utils_stpk.set_item_data(data_result,se_result)
			alife():register(se_result)
		else
			alife_create_item(result_details[i], npc)
		end
	end

	return true
end

local old_zzzz_arti_jamming_repairs_custom_disassembly_weapon = zzzz_arti_jamming_repairs.custom_disassembly_weapon
zzzz_arti_jamming_repairs.custom_disassembly_weapon = function(obj, obj_d)

	-- Defines
	local id = obj:id()
	local se_obj = alife_object(id)
	local sec = obj:section()
	local sec_p = ini_sys:r_string_ex(sec,"parent_section") or sec
	local name = ui_item.get_sec_name(sec)
	local con = obj:condition()
	local parts = item_parts.get_parts_con(obj, nil, true)
	local npc = obj:parent()
	if (not npc) then
		printf("~ item_parts | no owner found for [%s]", obj:name())
		return
	end

	local result_details = {}
	local result_conditions = {}
	local get_ammo = {}
	local with_scope = nil
	local delay = actor_effects.is_animations_on() and 3 or 0

	-- Collect attachments
	with_scope = utils_item.has_scope(sec)
	if with_scope then
		with_scope = string.format('_%s', utils_item.has_scope(sec))
		table.insert(result_details, with_scope:sub(2))
		sec = sec:gsub(with_scope, "")
	end
	if (obj:weapon_scope_status() == 2) and (utils_item.addon_attached(obj,"sc")) then
		local scope_section = utils_data.read_from_ini(nil,sec,"scopes_sect","string",nil)
		local scope = utils_data.read_from_ini(nil,scope_section,"scope_name","string",nil)
		table.insert(result_details, scope)
	end
	if (obj:weapon_silencer_status() == 2) and (utils_item.addon_attached(obj,"sl")) then
		local sil = utils_data.read_from_ini(nil,sec,"silencer_name","string",nil)
		table.insert(result_details, sil)
	end
	if (obj:weapon_grenadelauncher_status() == 2) and (utils_item.addon_attached(obj,"gl")) then
		local gl = utils_data.read_from_ini(nil,sec,"grenade_launcher_name","string",nil)
		table.insert(result_details, gl)
	end

	-- Unload mag and get ammo
	obj:force_unload_magazine(true)

	-- Collect weapon parts
	for k,v in pairs(parts) do
		if (k ~= sec_p) and v > 0 and (math.random(100) <= (zzzz_arti_jamming_repairs.disassembly_chance + con*100)) then
			local index = #result_details
			result_details[index + 1] = k
			result_conditions[index + 1] = IsItem("part",k) and utils_item.get_cond_static(v) or v
		end
	end

	-- Collect weapon spare parts
	for i=1,#zzzz_arti_jamming_repairs.spare_parts do
		local num = zzzz_arti_jamming_repairs.disassembly_weapon_spare_parts(sec, zzzz_arti_jamming_repairs.disassembly_chance/2)
		if (num > 0) then
			for j=1,num do
				table.insert(result_details,zzzz_arti_jamming_repairs.spare_parts[i])
			end
		end
	end

	-- Collect installed upgrades
	local installed_upgrades = utils_item.get_upgrades_installed(obj)
	local upgr_tools = {}

	for i=1,#installed_upgrades do
		local tool = utils_item.get_upgrade_sect_tool(sec, installed_upgrades[i])
		table.insert(upgr_tools,tool)
	end

	for i=1,#upgr_tools do
		if math.random(100) < con*50 then
			table.insert(result_details,upgr_tools[i])
		end
	end

	-- Release weapon
	alife_release(se_obj)

	-- Degrade disassemble tool
	local diss_tools = GetItemList("disassemble")
	local degr_val = diss_tools[obj_d:section()]
	local new_con = utils_item.degrade( obj_d , degr_val )

	-- Increase Statistic
	game_statistics.increment_statistic("items_disassembled")
	item_parts.clear_parts_con(id)

	-- Play animation
	actor_effects.play_item_fx("disassemble_metal_fast")

	-- Process
	CreateTimeEvent(0,"delay_disassembly" .. id, delay, timer_disassembly_weapon, npc:id(), result_details, result_conditions, name, obj_d:section(), new_con)
end